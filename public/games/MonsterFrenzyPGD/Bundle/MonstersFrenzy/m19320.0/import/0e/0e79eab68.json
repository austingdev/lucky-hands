[1,["edROfoSstH3o1b5L2UxH3s","1euuYoY45GxIz/6d76VJql","69F5lQu6BOApTIBWvIPO4M"],["_MainTex","_FlowMap","_effectAsset"],[["cc.Material",["_name","_techniqueData"],2,11],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,2],[1,0,1,2,4]],[[[[0,"KM_Particle_Flowmap_Gray2Tritone",[{},"0",11,[{"defines":{}},"props",11,[{"_TexFade":6},"_HCol",8,[4,3001417610],"_MCol",8,[4,2579453467],"_LCol",8,[4,4278190080],"_MainTex",6,0,"_FlowMap",6,1]]]]],0,0,[0,0,0],[0,1,2],[0,1,2]],[[[1,"KM_Particle_Flowmap_Gray2Tritone",[{"hash":1026998650,"record":null,"name":"KM_Particle_Flowmap_Gray2Tritone|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n#if CC_USE_SKINNING\n  in vec4 a_weights;\n  in vec4 a_joints;\n  #if CC_USE_JOINTS_TEXTRUE\n    uniform SKINNING {\n      vec2 jointsTextureSize;\n    };\n    uniform sampler2D jointsTexture;\n    #if CC_JOINTS_TEXTURE_FLOAT32\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 4.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = texture(jointsTexture, vec2(dx * (x + 0.5), y));\n        vec4 v2 = texture(jointsTexture, vec2(dx * (x + 1.5), y));\n        vec4 v3 = texture(jointsTexture, vec2(dx * (x + 2.5), y));\n        vec4 v4 = texture(jointsTexture, vec2(dx * (x + 3.5), y));\n        return mat4(v1, v2, v3, v4);\n      }\n    #else\n      float decode32(vec4 rgba) {\n        float Sign = 1.0 - step(128.0, rgba[0]) * 2.0;\n        float Exponent = 2.0 * mod(rgba[0], 128.0) + step(128.0, rgba[1]) - 127.0;\n        float Mantissa = mod(rgba[1], 128.0) * 65536.0 + rgba[2] * 256.0 + rgba[3] + 8388608.0;\n        return Sign * exp2(Exponent - 23.0) * Mantissa;\n      }\n      vec4 decodevec4 (vec4 x, vec4 y, vec4 z, vec4 w) {\n        return vec4(\n          decode32(x.wzyx * 255.0),\n          decode32(y.wzyx * 255.0),\n          decode32(z.wzyx * 255.0),\n          decode32(w.wzyx * 255.0)\n        );\n      }\n      vec4 decodevec4 (float dx, float x, float y) {\n        return decodevec4(\n          texture(jointsTexture, vec2(dx * (x + 0.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 1.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 2.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 3.5), y))\n        );\n      }\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 16.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = decodevec4(dx, x,       y);\n        vec4 v2 = decodevec4(dx, x+4.0,   y);\n        vec4 v3 = decodevec4(dx, x+8.0,   y);\n        vec4 v4 = decodevec4(dx, x+12.0,  y);\n        return mat4(v1, v2, v3, v4);\n      }\n    #endif\n  #else\n    uniform JOINT_MATRIX {\n      mat4 jointMatrices[50];\n    };\n    mat4 getBoneMatrix(const in float i) {\n      return jointMatrices[int(i)];\n    }\n  #endif\n    mat4 skinMatrix() {\n      return\n        getBoneMatrix(a_joints.x) * a_weights.x +\n        getBoneMatrix(a_joints.y) * a_weights.y +\n        getBoneMatrix(a_joints.z) * a_weights.z +\n        getBoneMatrix(a_joints.w) * a_weights.w\n        ;\n    }\n#endif\nstruct StandardVertInput {\n  vec2 uv;\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  vec4 color;\n};\nin vec3 a_position;\n#if CC_USE_ATTRIBUTE_UV0\nin vec2 a_uv0;\n#endif\n#if CC_USE_ATTRIBUTE_COLOR\nin vec4 a_color;\n#endif\n#if CC_USE_ATTRIBUTE_NORMAL\nin vec3 a_normal;\n#endif\n#if CC_USE_ATTRIBUTE_TANGENT\nin vec4 a_tangent;\n#endif\nvoid CCAttribute (out StandardVertInput In) {\n  In.position = vec4(a_position, 1.0);\n  #if CC_USE_ATTRIBUTE_UV0\n    In.uv = a_uv0;\n  #else\n    In.uv = vec2(0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_COLOR\n    In.color = a_color;\n  #else\n    In.color = vec4(1.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_NORMAL\n    In.normal = a_normal;\n  #else\n    In.normal = vec3(0.0, 1.0, 0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_TANGENT\n    In.tangent = a_tangent;\n  #else\n    In.tangent = vec4(1.0, 0.0, 0.0, 0.0);\n  #endif\n}\nvoid CCVertInput(out StandardVertInput In) {\n  CCAttribute(In);\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    In.position = m * In.position;\n    #if CC_USE_ATTRIBUTE_NORMAL\n      In.normal = (m * vec4(In.normal, 0)).xyz;\n    #endif\n    #if CC_USE_ATTRIBUTE_TANGENT\n      In.tangent = m * In.tangent;\n    #endif\n  #endif\n}\nuniform ConstantVS\n{\n   vec4 _Col;\n   vec4 _MainTex_ST;\n   vec4 _HCol;\n   vec4 _MCol;\n   vec4 _LCol;\n   float _FlowFreq;\n   int _TexFade;\n};\nout vec2 v_UV0;\nout vec2 v_FlowTime;\nout vec4 v_Col;\nout vec3 v_HC;\nout vec3 v_MC;\nout vec3 v_LC;\nvec4 vert ()\n{\n  StandardVertInput In;\n  CCVertInput(In);\n  v_FlowTime.x = mod(cc_time.x * 0.05 * _FlowFreq,31.4159);\n  vec4 _SinTime ;\n       _SinTime.x = sin(cc_time.x / 8.0 );\n       _SinTime.y = sin(cc_time.x / 4.0 );\n       _SinTime.z = sin(cc_time.z / 2.0 );\n       _SinTime.w = sin(cc_time.w / 1.0 );\n  if (_TexFade==0)      { v_FlowTime.y = abs(_SinTime.x); }\n  else if (_TexFade==1) { v_FlowTime.y = abs(_SinTime.y); }\n  else if (_TexFade==2) { v_FlowTime.y = abs(_SinTime.z); }\n  else  { v_FlowTime.y = abs(_SinTime.w);}\n  vec4 Col  = vec4( _Col.rgb/_Col.a  , 1.0);\n       Col.rgb  = mix( Col.rgb ,vec3(1,1,1), _Col.r) ;\n       Col.rgb  = Col.rgb *  _Col.g + (1.0-_Col.b)*5.0;\n  v_Col = Col;\n  vec4 PosWS = cc_matWorld * In.position;\n  v_UV0.xy    = In.uv * _MainTex_ST.xy + _MainTex_ST.zw;\n  v_HC = _HCol.rgb /_HCol.a;\n  v_MC = _MCol.rgb /_MCol.a;\n  v_LC = _LCol.rgb /_LCol.a;\n  vec4 pos = cc_matViewProj * PosWS;\n  return pos;\n}\nvoid main() {  gl_Position = vert();   }","frag":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\n#if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  uniform CC_SHADOW {\n    mat4 cc_shadow_lightViewProjMatrix[2];\n    vec4 cc_shadow_info[2];\n  };\n  #if CC_NUM_SHADOW_LIGHTS > 0\n    uniform sampler2D cc_shadow_map_0;\n  #endif\n  #if CC_NUM_SHADOW_LIGHTS > 1\n    uniform sampler2D cc_shadow_map_1;\n  #endif\n  varying vec4 v_posLightSpace[2];\n  varying float v_depth[2];\n#endif\n#if CC_NUM_LIGHTS > 0\nuniform CCLIGHTS {\n  vec4 cc_lightPositionAndRange[4];\n  vec4 cc_lightDirection[4];\n  vec4 cc_lightColor[4];\n};\n#endif\nstruct LightInfo {\n  vec3 lightDir;\n  vec3 radiance;\n  vec4 lightColor;\n};\nstruct Lighting {\n  vec3 diffuse;\n  vec3 specular;\n};\nin vec2 v_UV0;\nin vec2 v_FlowTime;\nin vec4 v_Col;\nin vec3 v_HC;\nin vec3 v_MC;\nin vec3 v_LC;\n uniform sampler2D _MainTex ;\n uniform sampler2D _FlowMap;\n uniform ConstantPS\n {\n    float _FlowSpeed;\n    float _Sat ;\n    float _Opacity;\n };\n  vec3  TriTone_PS( float Gray, vec3 HCol , vec3  MCol , vec3 LCol)\n  {\n    vec3 Tone1   = mix ( LCol  , MCol ,Gray*Gray);\n    vec3 Tone2   = mix ( MCol  , HCol  ,Gray*Gray);\n    vec3 TriTone = mix ( Tone1 , Tone2  ,Gray);\n    return TriTone ;\n  }\n  vec4 KM_FlowMap_Tritone(vec2 UV0 , vec2 FlowTime)\n  {\n      vec4  FlowDir = texture2D( _FlowMap , UV0 );\n            FlowDir.xy = FlowDir.xy * 2.0 - 1.0;\n            FlowDir.y  = -FlowDir.y;\n            FlowDir.xy = FlowDir.xy  * _FlowSpeed  ;\n      float Phase0 = fract(FlowTime.x + 0.5);\n      float Phase1 = fract(FlowTime.x);\n      vec4  Col0   = texture2D(_MainTex, UV0 - FlowDir.xy * Phase0 );\n      vec4  Col1   = texture2D(_MainTex, UV0 - FlowDir.xy * Phase1 );\n      vec4  RRRA0  = vec4(Col0.r,Col0.r,Col0.r,Col0.a);\n      vec4  GGGA0  = vec4(Col0.g,Col0.g,Col0.g,Col0.a);\n            Col0   = mix ( RRRA0 , GGGA0 , FlowTime.y );\n      vec4  RRRA1  = vec4(Col1.r,Col1.r,Col1.r,Col1.a);\n      vec4  GGGA1  = vec4(Col1.g,Col1.g,Col1.g,Col1.a);\n            Col1   = mix ( RRRA1 , GGGA1 , FlowTime.y );\n      float LerpF  = ( abs( 0.5 - Phase0  ) / 0.5);\n      vec4  Col    = mix ( Col0  , Col1  , LerpF );\n            Col.rgb = TriTone_PS(Col.g, v_HC , v_MC , v_LC );\n            Col.a = (Col.a * FlowDir.a);\n      return Col;\n  }\nvec4 frag ()\n{\n  vec4 Tex    = KM_FlowMap_Tritone( v_UV0.xy ,  v_FlowTime.xy);\n  float Luma  = dot(Tex.rgb, vec3(0.299,0.587,0.114));\n       Tex.rgb = mix( vec3(Luma,Luma,Luma ) , Tex.rgb, _Sat);\n       Tex.a = _Opacity;\n  return Tex * v_Col ;\n}\nvoid main()   {   gl_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_time;\nuniform mat4 cc_matWorld;\n#if CC_USE_SKINNING\n  attribute vec4 a_weights;\n  attribute vec4 a_joints;\n  #if CC_USE_JOINTS_TEXTRUE\n    uniform vec2 jointsTextureSize;\n    uniform sampler2D jointsTexture;\n    #if CC_JOINTS_TEXTURE_FLOAT32\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 4.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = texture2D(jointsTexture, vec2(dx * (x + 0.5), y));\n        vec4 v2 = texture2D(jointsTexture, vec2(dx * (x + 1.5), y));\n        vec4 v3 = texture2D(jointsTexture, vec2(dx * (x + 2.5), y));\n        vec4 v4 = texture2D(jointsTexture, vec2(dx * (x + 3.5), y));\n        return mat4(v1, v2, v3, v4);\n      }\n    #else\n      float decode32(vec4 rgba) {\n        float Sign = 1.0 - step(128.0, rgba[0]) * 2.0;\n        float Exponent = 2.0 * mod(rgba[0], 128.0) + step(128.0, rgba[1]) - 127.0;\n        float Mantissa = mod(rgba[1], 128.0) * 65536.0 + rgba[2] * 256.0 + rgba[3] + 8388608.0;\n        return Sign * exp2(Exponent - 23.0) * Mantissa;\n      }\n      vec4 decodevec4 (vec4 x, vec4 y, vec4 z, vec4 w) {\n        return vec4(\n          decode32(x.wzyx * 255.0),\n          decode32(y.wzyx * 255.0),\n          decode32(z.wzyx * 255.0),\n          decode32(w.wzyx * 255.0)\n        );\n      }\n      vec4 decodevec4 (float dx, float x, float y) {\n        return decodevec4(\n          texture2D(jointsTexture, vec2(dx * (x + 0.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 1.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 2.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 3.5), y))\n        );\n      }\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 16.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = decodevec4(dx, x,       y);\n        vec4 v2 = decodevec4(dx, x+4.0,   y);\n        vec4 v3 = decodevec4(dx, x+8.0,   y);\n        vec4 v4 = decodevec4(dx, x+12.0,  y);\n        return mat4(v1, v2, v3, v4);\n      }\n    #endif\n  #else\n    uniform mat4 jointMatrices[50];\n    mat4 getBoneMatrix(const in float i) {\n      return jointMatrices[int(i)];\n    }\n  #endif\n    mat4 skinMatrix() {\n      return\n        getBoneMatrix(a_joints.x) * a_weights.x +\n        getBoneMatrix(a_joints.y) * a_weights.y +\n        getBoneMatrix(a_joints.z) * a_weights.z +\n        getBoneMatrix(a_joints.w) * a_weights.w\n        ;\n    }\n#endif\nstruct StandardVertInput {\n  vec2 uv;\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  vec4 color;\n};\nattribute vec3 a_position;\n#if CC_USE_ATTRIBUTE_UV0\nattribute vec2 a_uv0;\n#endif\n#if CC_USE_ATTRIBUTE_COLOR\nattribute vec4 a_color;\n#endif\n#if CC_USE_ATTRIBUTE_NORMAL\nattribute vec3 a_normal;\n#endif\n#if CC_USE_ATTRIBUTE_TANGENT\nattribute vec4 a_tangent;\n#endif\nvoid CCAttribute (out StandardVertInput In) {\n  In.position = vec4(a_position, 1.0);\n  #if CC_USE_ATTRIBUTE_UV0\n    In.uv = a_uv0;\n  #else\n    In.uv = vec2(0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_COLOR\n    In.color = a_color;\n  #else\n    In.color = vec4(1.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_NORMAL\n    In.normal = a_normal;\n  #else\n    In.normal = vec3(0.0, 1.0, 0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_TANGENT\n    In.tangent = a_tangent;\n  #else\n    In.tangent = vec4(1.0, 0.0, 0.0, 0.0);\n  #endif\n}\nvoid CCVertInput(out StandardVertInput In) {\n  CCAttribute(In);\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    In.position = m * In.position;\n    #if CC_USE_ATTRIBUTE_NORMAL\n      In.normal = (m * vec4(In.normal, 0)).xyz;\n    #endif\n    #if CC_USE_ATTRIBUTE_TANGENT\n      In.tangent = m * In.tangent;\n    #endif\n  #endif\n}\nuniform vec4 _Col;\nuniform vec4 _MainTex_ST;\nuniform vec4 _HCol;\nuniform vec4 _MCol;\nuniform vec4 _LCol;\nuniform float _FlowFreq;\nuniform int _TexFade;\nvarying vec2 v_UV0;\nvarying vec2 v_FlowTime;\nvarying vec4 v_Col;\nvarying vec3 v_HC;\nvarying vec3 v_MC;\nvarying vec3 v_LC;\nvec4 vert ()\n{\n  StandardVertInput In;\n  CCVertInput(In);\n  v_FlowTime.x = mod(cc_time.x * 0.05 * _FlowFreq,31.4159);\n  vec4 _SinTime ;\n       _SinTime.x = sin(cc_time.x / 8.0 );\n       _SinTime.y = sin(cc_time.x / 4.0 );\n       _SinTime.z = sin(cc_time.z / 2.0 );\n       _SinTime.w = sin(cc_time.w / 1.0 );\n  if (_TexFade==0)      { v_FlowTime.y = abs(_SinTime.x); }\n  else if (_TexFade==1) { v_FlowTime.y = abs(_SinTime.y); }\n  else if (_TexFade==2) { v_FlowTime.y = abs(_SinTime.z); }\n  else  { v_FlowTime.y = abs(_SinTime.w);}\n  vec4 Col  = vec4( _Col.rgb/_Col.a  , 1.0);\n       Col.rgb  = mix( Col.rgb ,vec3(1,1,1), _Col.r) ;\n       Col.rgb  = Col.rgb *  _Col.g + (1.0-_Col.b)*5.0;\n  v_Col = Col;\n  vec4 PosWS = cc_matWorld * In.position;\n  v_UV0.xy    = In.uv * _MainTex_ST.xy + _MainTex_ST.zw;\n  v_HC = _HCol.rgb /_HCol.a;\n  v_MC = _MCol.rgb /_MCol.a;\n  v_LC = _LCol.rgb /_LCol.a;\n  vec4 pos = cc_matViewProj * PosWS;\n  return pos;\n}\nvoid main() {  gl_Position = vert();   }","frag":"\nprecision highp float;\n#if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  #if CC_NUM_SHADOW_LIGHTS > 0\n    uniform sampler2D cc_shadow_map_0;\n  #endif\n  #if CC_NUM_SHADOW_LIGHTS > 1\n    uniform sampler2D cc_shadow_map_1;\n  #endif\n  varying vec4 v_posLightSpace[2];\n  varying float v_depth[2];\n#endif\n#if CC_NUM_LIGHTS > 0\n#endif\nstruct LightInfo {\n  vec3 lightDir;\n  vec3 radiance;\n  vec4 lightColor;\n};\nstruct Lighting {\n  vec3 diffuse;\n  vec3 specular;\n};\nvarying vec2 v_UV0;\nvarying vec2 v_FlowTime;\nvarying vec4 v_Col;\nvarying vec3 v_HC;\nvarying vec3 v_MC;\nvarying vec3 v_LC;\n uniform sampler2D _MainTex ;\n uniform sampler2D _FlowMap;\n uniform float _FlowSpeed;\nuniform float _Sat;\nuniform float _Opacity;\n  vec3  TriTone_PS( float Gray, vec3 HCol , vec3  MCol , vec3 LCol)\n  {\n    vec3 Tone1   = mix ( LCol  , MCol ,Gray*Gray);\n    vec3 Tone2   = mix ( MCol  , HCol  ,Gray*Gray);\n    vec3 TriTone = mix ( Tone1 , Tone2  ,Gray);\n    return TriTone ;\n  }\n  vec4 KM_FlowMap_Tritone(vec2 UV0 , vec2 FlowTime)\n  {\n      vec4  FlowDir = texture2D( _FlowMap , UV0 );\n            FlowDir.xy = FlowDir.xy * 2.0 - 1.0;\n            FlowDir.y  = -FlowDir.y;\n            FlowDir.xy = FlowDir.xy  * _FlowSpeed  ;\n      float Phase0 = fract(FlowTime.x + 0.5);\n      float Phase1 = fract(FlowTime.x);\n      vec4  Col0   = texture2D(_MainTex, UV0 - FlowDir.xy * Phase0 );\n      vec4  Col1   = texture2D(_MainTex, UV0 - FlowDir.xy * Phase1 );\n      vec4  RRRA0  = vec4(Col0.r,Col0.r,Col0.r,Col0.a);\n      vec4  GGGA0  = vec4(Col0.g,Col0.g,Col0.g,Col0.a);\n            Col0   = mix ( RRRA0 , GGGA0 , FlowTime.y );\n      vec4  RRRA1  = vec4(Col1.r,Col1.r,Col1.r,Col1.a);\n      vec4  GGGA1  = vec4(Col1.g,Col1.g,Col1.g,Col1.a);\n            Col1   = mix ( RRRA1 , GGGA1 , FlowTime.y );\n      float LerpF  = ( abs( 0.5 - Phase0  ) / 0.5);\n      vec4  Col    = mix ( Col0  , Col1  , LerpF );\n            Col.rgb = TriTone_PS(Col.g, v_HC , v_MC , v_LC );\n            Col.a = (Col.a * FlowDir.a);\n      return Col;\n  }\nvec4 frag ()\n{\n  vec4 Tex    = KM_FlowMap_Tritone( v_UV0.xy ,  v_FlowTime.xy);\n  float Luma  = dot(Tex.rgb, vec3(0.299,0.587,0.114));\n       Tex.rgb = mix( vec3(Luma,Luma,Luma ) , Tex.rgb, _Sat);\n       Tex.a = _Opacity;\n  return Tex * v_Col ;\n}\nvoid main()   {   gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CC_SHADOW","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]},{"name":"CCLIGHTS","defines":["CC_NUM_LIGHTS"]}],"samplers":[{"name":"cc_shadow_map_0","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]},{"name":"cc_shadow_map_1","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]}]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_JOINTS_TEXTRUE","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"CC_JOINTS_TEXTURE_FLOAT32","type":"boolean","defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"CC_USE_ATTRIBUTE_UV0","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_COLOR","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_NORMAL","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_TANGENT","type":"boolean","defines":[]},{"name":"CC_USE_SHADOW_MAP","type":"boolean","defines":[]},{"name":"CC_NUM_SHADOW_LIGHTS","type":"number","defines":["CC_USE_SHADOW_MAP"],"range":[0,3]},{"name":"CC_NUM_LIGHTS","type":"number","defines":[],"range":[0,3]}],"blocks":[{"name":"SKINNING","binding":0,"members":[{"name":"jointsTextureSize","type":14,"count":1}],"defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"JOINT_MATRIX","binding":1,"members":[{"name":"jointMatrices","type":26,"count":50}],"defines":["CC_USE_SKINNING"]},{"name":"ConstantVS","binding":2,"members":[{"name":"_Col","type":16,"count":1},{"name":"_MainTex_ST","type":16,"count":1},{"name":"_HCol","type":16,"count":1},{"name":"_MCol","type":16,"count":1},{"name":"_LCol","type":16,"count":1},{"name":"_FlowFreq","type":13,"count":1},{"name":"_TexFade","type":5,"count":1}],"defines":[]},{"name":"ConstantPS","binding":3,"members":[{"name":"_FlowSpeed","type":13,"count":1},{"name":"_Sat","type":13,"count":1},{"name":"_Opacity","type":13,"count":1}],"defines":[]}],"samplers":[{"name":"jointsTexture","type":29,"count":1,"binding":30,"defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"_MainTex","type":29,"count":1,"binding":31,"defines":[]},{"name":"_FlowMap","type":29,"count":1,"binding":32,"defines":[]}]}],[{"passes":[{"name":"KM_Particle_Flowmap_Gray2Tritone","program":"KM_Particle_Flowmap_Gray2Tritone|vs|fs","blendState":{"targets":[{"blend":true,"blendSrc":770,"blendDst":771,"blendSrcAlpha":770,"blendDstAlpha":771}]},"rasterizerState":{"cullMode":1029},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"_Col":{"type":16,"value":[1,1,1,0.5],"editor":{"displayName":"三種調色法 (Alpha=Intensity)","type":"color"}},"_MainTex":{"value":"black","type":29,"editor":{"displayName":"兩張灰階放在R/G通道"}},"_MainTex_ST":{"type":16,"value":[1,1,0,0],"editor":{"displayName":"UV縮放偏移"}},"_TexFade":{"type":5,"value":[2],"editor":{"displayName":"R與G通道漸變的頻率 慢0 中1 快2 超快3"}},"_FlowMap":{"value":"Gray","type":29,"editor":{"displayName":"FlowMap流向圖 (Alpha當遮罩)"}},"_FlowFreq":{"type":13,"value":[3],"editor":{"displayName":"Flow頻率 1~10"}},"_FlowSpeed":{"type":13,"value":[0.5],"editor":{"displayName":"Flow速度 -0.5~0.5"}},"_HCol":{"type":16,"value":[0.7,0.8,0.5,0.7],"editor":{"displayName":"染色亮部色(Alpha=Intensity)","type":"color"}},"_MCol":{"type":16,"value":[0.7,2,0.4,0.6],"editor":{"displayName":"染色中間色(Alpha=Intensity)","type":"color"}},"_LCol":{"type":16,"value":[0.2,0,0,1],"editor":{"displayName":"染色暗部色","type":"color"}},"_Sat":{"type":13,"value":[1.5],"editor":{"displayName":"Saturate飽和度調整"}},"_Opacity":{"type":13,"value":[1],"editor":{"displayName":"圖像透明度"}}}}]}]]],0,0,[],[],[]]]]