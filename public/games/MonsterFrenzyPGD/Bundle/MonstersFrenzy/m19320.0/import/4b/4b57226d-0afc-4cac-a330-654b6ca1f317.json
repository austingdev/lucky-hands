[1,0,0,[["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,2,4]],[[0,"KM_Matcap_Rim",[{"hash":852409679,"record":null,"name":"KM_Matcap_Rim|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n#if CC_USE_SKINNING\n  in vec4 a_weights;\n  in vec4 a_joints;\n  #if CC_USE_JOINTS_TEXTRUE\n    uniform SKINNING {\n      vec2 jointsTextureSize;\n    };\n    uniform sampler2D jointsTexture;\n    #if CC_JOINTS_TEXTURE_FLOAT32\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 4.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = texture(jointsTexture, vec2(dx * (x + 0.5), y));\n        vec4 v2 = texture(jointsTexture, vec2(dx * (x + 1.5), y));\n        vec4 v3 = texture(jointsTexture, vec2(dx * (x + 2.5), y));\n        vec4 v4 = texture(jointsTexture, vec2(dx * (x + 3.5), y));\n        return mat4(v1, v2, v3, v4);\n      }\n    #else\n      float decode32(vec4 rgba) {\n        float Sign = 1.0 - step(128.0, rgba[0]) * 2.0;\n        float Exponent = 2.0 * mod(rgba[0], 128.0) + step(128.0, rgba[1]) - 127.0;\n        float Mantissa = mod(rgba[1], 128.0) * 65536.0 + rgba[2] * 256.0 + rgba[3] + 8388608.0;\n        return Sign * exp2(Exponent - 23.0) * Mantissa;\n      }\n      vec4 decodevec4 (vec4 x, vec4 y, vec4 z, vec4 w) {\n        return vec4(\n          decode32(x.wzyx * 255.0),\n          decode32(y.wzyx * 255.0),\n          decode32(z.wzyx * 255.0),\n          decode32(w.wzyx * 255.0)\n        );\n      }\n      vec4 decodevec4 (float dx, float x, float y) {\n        return decodevec4(\n          texture(jointsTexture, vec2(dx * (x + 0.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 1.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 2.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 3.5), y))\n        );\n      }\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 16.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = decodevec4(dx, x,       y);\n        vec4 v2 = decodevec4(dx, x+4.0,   y);\n        vec4 v3 = decodevec4(dx, x+8.0,   y);\n        vec4 v4 = decodevec4(dx, x+12.0,  y);\n        return mat4(v1, v2, v3, v4);\n      }\n    #endif\n  #else\n    uniform JOINT_MATRIX {\n      mat4 jointMatrices[50];\n    };\n    mat4 getBoneMatrix(const in float i) {\n      return jointMatrices[int(i)];\n    }\n  #endif\n    mat4 skinMatrix() {\n      return\n        getBoneMatrix(a_joints.x) * a_weights.x +\n        getBoneMatrix(a_joints.y) * a_weights.y +\n        getBoneMatrix(a_joints.z) * a_weights.z +\n        getBoneMatrix(a_joints.w) * a_weights.w\n        ;\n    }\n#endif\nstruct StandardVertInput {\n  vec2 uv;\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  vec4 color;\n};\nin vec3 a_position;\n#if CC_USE_ATTRIBUTE_UV0\nin vec2 a_uv0;\n#endif\n#if CC_USE_ATTRIBUTE_COLOR\nin vec4 a_color;\n#endif\n#if CC_USE_ATTRIBUTE_NORMAL\nin vec3 a_normal;\n#endif\n#if CC_USE_ATTRIBUTE_TANGENT\nin vec4 a_tangent;\n#endif\nvoid CCAttribute (out StandardVertInput In) {\n  In.position = vec4(a_position, 1.0);\n  #if CC_USE_ATTRIBUTE_UV0\n    In.uv = a_uv0;\n  #else\n    In.uv = vec2(0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_COLOR\n    In.color = a_color;\n  #else\n    In.color = vec4(1.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_NORMAL\n    In.normal = a_normal;\n  #else\n    In.normal = vec3(0.0, 1.0, 0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_TANGENT\n    In.tangent = a_tangent;\n  #else\n    In.tangent = vec4(1.0, 0.0, 0.0, 0.0);\n  #endif\n}\nvoid CCVertInput(out StandardVertInput In) {\n  CCAttribute(In);\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    In.position = m * In.position;\n    #if CC_USE_ATTRIBUTE_NORMAL\n      In.normal = (m * vec4(In.normal, 0)).xyz;\n    #endif\n    #if CC_USE_ATTRIBUTE_TANGENT\n      In.tangent = m * In.tangent;\n    #endif\n  #endif\n}\nuniform ConstantVS\n{\n   vec4 _TileOffset;\n   vec4 _AddColor;\n   vec4 _RimCol;\n   vec4 _DTileOffset;\n   float _AddColorIntensity;\n   float _RimSoft;\n   float _Rim;\n   float _DEdge;\n};\nout vec3 v_PosWS;\nout vec4 v_UV;\nout vec3 v_NrmWS;\nout vec3 v_VDirWS;\nout vec2 v_UVmc;\nout vec4 v_AddCol;\nout vec4 v_RimCol;\nvec4 KM_Rim_VS(vec3 NrmWS,vec3 VDirWS)\n{\n   float NdotV = max(0.0,dot(v_VDirWS, v_NrmWS));\n   float Rim   = pow(1.0 - NdotV, _RimSoft) * _Rim;\n   return vec4(Rim * (_RimCol.rgb+1.0), Rim );\n}\nvec4 vert ()\n{\n  StandardVertInput In;\n  CCVertInput(In);\n  vec4 PosWS = cc_matWorld * In.position;\n  v_PosWS    = PosWS.xyz;\n  v_UV.xy    = In.uv * _TileOffset.xy + _TileOffset.zw;\n  v_UV.zw    = In.uv * _DTileOffset.xy + _DTileOffset.zw;\n  v_NrmWS    = ( cc_matWorldIT * vec4( In.normal, 0.0)).xyz;\n  v_NrmWS    = normalize(v_NrmWS);\n  v_VDirWS   = normalize( cc_cameraPos.xyz - PosWS.xyz);\n  vec3 NrmX  = cc_matWorld[0].xyz * In.normal.x;\n  vec3 NrmY  = cc_matWorld[1].xyz * In.normal.y;\n  vec3 NrmZ  = cc_matWorld[2].xyz * In.normal.z;\n  vec3 NrmWS = normalize(NrmX + NrmY + NrmZ);\n  vec3 NrmVS = mat3( cc_matView) * NrmWS;\n   v_UVmc.xy = NrmVS.xy * 0.5 + 0.5;\n  v_RimCol = KM_Rim_VS( v_NrmWS, v_VDirWS) ;\n  v_AddCol.rgb = _AddColor.rgb * _AddColorIntensity;\n  v_AddCol.a   =  1.0 / _DEdge;\n  vec4 pos = cc_matViewProj * PosWS;\n  return pos;\n}\nvoid main() {  gl_Position = vert();   }","frag":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\n#if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  uniform CC_SHADOW {\n    mat4 cc_shadow_lightViewProjMatrix[2];\n    vec4 cc_shadow_info[2];\n  };\n  #if CC_NUM_SHADOW_LIGHTS > 0\n    uniform sampler2D cc_shadow_map_0;\n  #endif\n  #if CC_NUM_SHADOW_LIGHTS > 1\n    uniform sampler2D cc_shadow_map_1;\n  #endif\n  varying vec4 v_posLightSpace[2];\n  varying float v_depth[2];\n#endif\n#if CC_NUM_LIGHTS > 0\nuniform CCLIGHTS {\n  vec4 cc_lightPositionAndRange[4];\n  vec4 cc_lightDirection[4];\n  vec4 cc_lightColor[4];\n};\n#endif\nstruct LightInfo {\n  vec3 lightDir;\n  vec3 radiance;\n  vec4 lightColor;\n};\nstruct Lighting {\n  vec3 diffuse;\n  vec3 specular;\n};\nin vec3 v_PosWS;\nin vec4 v_UV;\nin vec2 v_UVmc;\nin vec3 v_VDirWS;\nin vec3 v_NrmWS;\nin vec4 v_AddCol;\nin vec4 v_RimCol;\n uniform sampler2D _MainTex ;\n uniform sampler2D _Matcap;\n uniform sampler2D _DissolveTex;\n uniform sampler2D _RampTex;\nuniform Constant\n{\n  vec4 _Color;\n  float _Wrap;\n  float _Lum;\n  float _Spec;\n  float _Sat ;\n  float _Cont ;\n  float _DThres;\n  float _DEdge;\n};\nvec3 SaturateContrast_PS(vec3 Col, float Sat, float Cont)\n{\n      float  Gray = Col.g;\n              Col = mix( vec3(Gray,Gray,Gray) , Col, Sat);\n              Col = (Col - 0.5) * Cont + 0.5;\n      return Col;\n}\nvec4 frag ()\n{\n  vec4 Tex    = texture2D( _MainTex , v_UV.xy );\n  #if (USE_ALPHA_TEST)\n  { if(Tex.a < 0.02) { discard; } }\n  #endif\n      Tex.rgb = SaturateContrast_PS(Tex.rgb ,  _Sat, _Cont);\n  vec4 Matcap  = texture2D( _Matcap, v_UVmc );\n       Matcap.rgb = (Matcap.rgb * _Lum + _Wrap) / (1.0 + _Wrap);\n  float SpecMasked = Tex.a * Matcap.a * _Spec;\n  vec4 Col     = vec4(Tex.rgb * (Matcap.rgb +SpecMasked), Tex.a );\n       Col.rgb = mix(Col.rgb , v_RimCol.rgb * Col.rgb ,v_RimCol.a);\n       Col.rgb = Col.rgb * _Color.rgb;\n  #if (UseDissolve)\n      float DissTex = texture2D(_DissolveTex, v_UV.zw).r;\n      float CutMask = DissTex - _DThres;\n      float Bool01 = step(_DThres, DissTex);\n      if(CutMask < 0.0 ) { discard; }\n      float Clamp01 = clamp(CutMask * _DEdge,0.0,1.0);\n  vec3 RampCol = texture2D(_RampTex, vec2( Clamp01 ,1.0) ).rgb;\n       RampCol = RampCol * step(CutMask, v_AddCol.a);\n       RampCol = mix( vec3(0,0,0), RampCol , Bool01 );\n       Col.rgb += RampCol.rgb;\n   #endif\n  Col.rgb += v_AddCol.rgb;\n  return Col ;\n}\nvoid main()   {   gl_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_cameraPos;\nuniform mat4 cc_matWorld;\nuniform mat4 cc_matWorldIT;\n#if CC_USE_SKINNING\n  attribute vec4 a_weights;\n  attribute vec4 a_joints;\n  #if CC_USE_JOINTS_TEXTRUE\n    uniform vec2 jointsTextureSize;\n    uniform sampler2D jointsTexture;\n    #if CC_JOINTS_TEXTURE_FLOAT32\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 4.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = texture2D(jointsTexture, vec2(dx * (x + 0.5), y));\n        vec4 v2 = texture2D(jointsTexture, vec2(dx * (x + 1.5), y));\n        vec4 v3 = texture2D(jointsTexture, vec2(dx * (x + 2.5), y));\n        vec4 v4 = texture2D(jointsTexture, vec2(dx * (x + 3.5), y));\n        return mat4(v1, v2, v3, v4);\n      }\n    #else\n      float decode32(vec4 rgba) {\n        float Sign = 1.0 - step(128.0, rgba[0]) * 2.0;\n        float Exponent = 2.0 * mod(rgba[0], 128.0) + step(128.0, rgba[1]) - 127.0;\n        float Mantissa = mod(rgba[1], 128.0) * 65536.0 + rgba[2] * 256.0 + rgba[3] + 8388608.0;\n        return Sign * exp2(Exponent - 23.0) * Mantissa;\n      }\n      vec4 decodevec4 (vec4 x, vec4 y, vec4 z, vec4 w) {\n        return vec4(\n          decode32(x.wzyx * 255.0),\n          decode32(y.wzyx * 255.0),\n          decode32(z.wzyx * 255.0),\n          decode32(w.wzyx * 255.0)\n        );\n      }\n      vec4 decodevec4 (float dx, float x, float y) {\n        return decodevec4(\n          texture2D(jointsTexture, vec2(dx * (x + 0.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 1.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 2.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 3.5), y))\n        );\n      }\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 16.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = decodevec4(dx, x,       y);\n        vec4 v2 = decodevec4(dx, x+4.0,   y);\n        vec4 v3 = decodevec4(dx, x+8.0,   y);\n        vec4 v4 = decodevec4(dx, x+12.0,  y);\n        return mat4(v1, v2, v3, v4);\n      }\n    #endif\n  #else\n    uniform mat4 jointMatrices[50];\n    mat4 getBoneMatrix(const in float i) {\n      return jointMatrices[int(i)];\n    }\n  #endif\n    mat4 skinMatrix() {\n      return\n        getBoneMatrix(a_joints.x) * a_weights.x +\n        getBoneMatrix(a_joints.y) * a_weights.y +\n        getBoneMatrix(a_joints.z) * a_weights.z +\n        getBoneMatrix(a_joints.w) * a_weights.w\n        ;\n    }\n#endif\nstruct StandardVertInput {\n  vec2 uv;\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  vec4 color;\n};\nattribute vec3 a_position;\n#if CC_USE_ATTRIBUTE_UV0\nattribute vec2 a_uv0;\n#endif\n#if CC_USE_ATTRIBUTE_COLOR\nattribute vec4 a_color;\n#endif\n#if CC_USE_ATTRIBUTE_NORMAL\nattribute vec3 a_normal;\n#endif\n#if CC_USE_ATTRIBUTE_TANGENT\nattribute vec4 a_tangent;\n#endif\nvoid CCAttribute (out StandardVertInput In) {\n  In.position = vec4(a_position, 1.0);\n  #if CC_USE_ATTRIBUTE_UV0\n    In.uv = a_uv0;\n  #else\n    In.uv = vec2(0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_COLOR\n    In.color = a_color;\n  #else\n    In.color = vec4(1.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_NORMAL\n    In.normal = a_normal;\n  #else\n    In.normal = vec3(0.0, 1.0, 0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_TANGENT\n    In.tangent = a_tangent;\n  #else\n    In.tangent = vec4(1.0, 0.0, 0.0, 0.0);\n  #endif\n}\nvoid CCVertInput(out StandardVertInput In) {\n  CCAttribute(In);\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    In.position = m * In.position;\n    #if CC_USE_ATTRIBUTE_NORMAL\n      In.normal = (m * vec4(In.normal, 0)).xyz;\n    #endif\n    #if CC_USE_ATTRIBUTE_TANGENT\n      In.tangent = m * In.tangent;\n    #endif\n  #endif\n}\nuniform vec4 _TileOffset;\nuniform vec4 _AddColor;\nuniform vec4 _RimCol;\nuniform vec4 _DTileOffset;\nuniform float _AddColorIntensity;\nuniform float _RimSoft;\nuniform float _Rim;\nuniform float _DEdge;\nvarying vec3 v_PosWS;\nvarying vec4 v_UV;\nvarying vec3 v_NrmWS;\nvarying vec3 v_VDirWS;\nvarying vec2 v_UVmc;\nvarying vec4 v_AddCol;\nvarying vec4 v_RimCol;\nvec4 KM_Rim_VS(vec3 NrmWS,vec3 VDirWS)\n{\n   float NdotV = max(0.0,dot(v_VDirWS, v_NrmWS));\n   float Rim   = pow(1.0 - NdotV, _RimSoft) * _Rim;\n   return vec4(Rim * (_RimCol.rgb+1.0), Rim );\n}\nvec4 vert ()\n{\n  StandardVertInput In;\n  CCVertInput(In);\n  vec4 PosWS = cc_matWorld * In.position;\n  v_PosWS    = PosWS.xyz;\n  v_UV.xy    = In.uv * _TileOffset.xy + _TileOffset.zw;\n  v_UV.zw    = In.uv * _DTileOffset.xy + _DTileOffset.zw;\n  v_NrmWS    = ( cc_matWorldIT * vec4( In.normal, 0.0)).xyz;\n  v_NrmWS    = normalize(v_NrmWS);\n  v_VDirWS   = normalize( cc_cameraPos.xyz - PosWS.xyz);\n  vec3 NrmX  = cc_matWorld[0].xyz * In.normal.x;\n  vec3 NrmY  = cc_matWorld[1].xyz * In.normal.y;\n  vec3 NrmZ  = cc_matWorld[2].xyz * In.normal.z;\n  vec3 NrmWS = normalize(NrmX + NrmY + NrmZ);\n  vec3 NrmVS = mat3( cc_matView) * NrmWS;\n   v_UVmc.xy = NrmVS.xy * 0.5 + 0.5;\n  v_RimCol = KM_Rim_VS( v_NrmWS, v_VDirWS) ;\n  v_AddCol.rgb = _AddColor.rgb * _AddColorIntensity;\n  v_AddCol.a   =  1.0 / _DEdge;\n  vec4 pos = cc_matViewProj * PosWS;\n  return pos;\n}\nvoid main() {  gl_Position = vert();   }","frag":"\nprecision highp float;\n#if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  #if CC_NUM_SHADOW_LIGHTS > 0\n    uniform sampler2D cc_shadow_map_0;\n  #endif\n  #if CC_NUM_SHADOW_LIGHTS > 1\n    uniform sampler2D cc_shadow_map_1;\n  #endif\n  varying vec4 v_posLightSpace[2];\n  varying float v_depth[2];\n#endif\n#if CC_NUM_LIGHTS > 0\n#endif\nstruct LightInfo {\n  vec3 lightDir;\n  vec3 radiance;\n  vec4 lightColor;\n};\nstruct Lighting {\n  vec3 diffuse;\n  vec3 specular;\n};\nvarying vec3 v_PosWS;\nvarying vec4 v_UV;\nvarying vec2 v_UVmc;\nvarying vec3 v_VDirWS;\nvarying vec3 v_NrmWS;\nvarying vec4 v_AddCol;\nvarying vec4 v_RimCol;\n uniform sampler2D _MainTex ;\n uniform sampler2D _Matcap;\n uniform sampler2D _DissolveTex;\n uniform sampler2D _RampTex;\nuniform vec4 _Color;\nuniform float _Wrap;\nuniform float _Lum;\nuniform float _Spec;\nuniform float _Sat;\nuniform float _Cont;\nuniform float _DThres;\nuniform float _DEdge;\nvec3 SaturateContrast_PS(vec3 Col, float Sat, float Cont)\n{\n      float  Gray = Col.g;\n              Col = mix( vec3(Gray,Gray,Gray) , Col, Sat);\n              Col = (Col - 0.5) * Cont + 0.5;\n      return Col;\n}\nvec4 frag ()\n{\n  vec4 Tex    = texture2D( _MainTex , v_UV.xy );\n  #if (USE_ALPHA_TEST)\n  { if(Tex.a < 0.02) { discard; } }\n  #endif\n      Tex.rgb = SaturateContrast_PS(Tex.rgb ,  _Sat, _Cont);\n  vec4 Matcap  = texture2D( _Matcap, v_UVmc );\n       Matcap.rgb = (Matcap.rgb * _Lum + _Wrap) / (1.0 + _Wrap);\n  float SpecMasked = Tex.a * Matcap.a * _Spec;\n  vec4 Col     = vec4(Tex.rgb * (Matcap.rgb +SpecMasked), Tex.a );\n       Col.rgb = mix(Col.rgb , v_RimCol.rgb * Col.rgb ,v_RimCol.a);\n       Col.rgb = Col.rgb * _Color.rgb;\n  #if (UseDissolve)\n      float DissTex = texture2D(_DissolveTex, v_UV.zw).r;\n      float CutMask = DissTex - _DThres;\n      float Bool01 = step(_DThres, DissTex);\n      if(CutMask < 0.0 ) { discard; }\n      float Clamp01 = clamp(CutMask * _DEdge,0.0,1.0);\n  vec3 RampCol = texture2D(_RampTex, vec2( Clamp01 ,1.0) ).rgb;\n       RampCol = RampCol * step(CutMask, v_AddCol.a);\n       RampCol = mix( vec3(0,0,0), RampCol , Bool01 );\n       Col.rgb += RampCol.rgb;\n   #endif\n  Col.rgb += v_AddCol.rgb;\n  return Col ;\n}\nvoid main()   {   gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CC_SHADOW","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]},{"name":"CCLIGHTS","defines":["CC_NUM_LIGHTS"]}],"samplers":[{"name":"cc_shadow_map_0","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]},{"name":"cc_shadow_map_1","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]}]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_JOINTS_TEXTRUE","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"CC_JOINTS_TEXTURE_FLOAT32","type":"boolean","defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"CC_USE_ATTRIBUTE_UV0","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_COLOR","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_NORMAL","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_TANGENT","type":"boolean","defines":[]},{"name":"CC_USE_SHADOW_MAP","type":"boolean","defines":[]},{"name":"CC_NUM_SHADOW_LIGHTS","type":"number","defines":["CC_USE_SHADOW_MAP"],"range":[0,3]},{"name":"CC_NUM_LIGHTS","type":"number","defines":[],"range":[0,3]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"UseDissolve","type":"boolean","defines":[]}],"blocks":[{"name":"SKINNING","binding":0,"members":[{"name":"jointsTextureSize","type":14,"count":1}],"defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"JOINT_MATRIX","binding":1,"members":[{"name":"jointMatrices","type":26,"count":50}],"defines":["CC_USE_SKINNING"]},{"name":"ConstantVS","binding":2,"members":[{"name":"_TileOffset","type":16,"count":1},{"name":"_AddColor","type":16,"count":1},{"name":"_RimCol","type":16,"count":1},{"name":"_DTileOffset","type":16,"count":1},{"name":"_AddColorIntensity","type":13,"count":1},{"name":"_RimSoft","type":13,"count":1},{"name":"_Rim","type":13,"count":1},{"name":"_DEdge","type":13,"count":1}],"defines":[]},{"name":"Constant","binding":3,"members":[{"name":"_Color","type":16,"count":1},{"name":"_Wrap","type":13,"count":1},{"name":"_Lum","type":13,"count":1},{"name":"_Spec","type":13,"count":1},{"name":"_Sat","type":13,"count":1},{"name":"_Cont","type":13,"count":1},{"name":"_DThres","type":13,"count":1},{"name":"_DEdge","type":13,"count":1}],"defines":[]}],"samplers":[{"name":"jointsTexture","type":29,"count":1,"binding":30,"defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"_MainTex","type":29,"count":1,"binding":31,"defines":[]},{"name":"_Matcap","type":29,"count":1,"binding":32,"defines":[]},{"name":"_DissolveTex","type":29,"count":1,"binding":33,"defines":[]},{"name":"_RampTex","type":29,"count":1,"binding":34,"defines":[]}]}],[{"passes":[{"name":"KM_Matcap_Rim","program":"KM_Matcap_Rim|vs|fs","blendState":{"targets":[{"blend":false,"blendSrc":770,"blendDst":771,"blendSrcAlpha":770,"blendDstAlpha":771}]},"rasterizerState":{"cullMode":1029},"depthStencilState":{"depthTest":true,"depthWrite":true},"properties":{"_Color":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"_MainTex":{"value":"white","type":29},"_TileOffset":{"type":16,"value":[1,1,0,0],"editor":{"displayName":"UV縮放偏移"}},"_Matcap":{"value":"white","type":29},"_Wrap":{"type":13,"value":[2],"editor":{"displayName":"WrapLight環繞光=調整暗部"}},"_Lum":{"type":13,"value":[1],"editor":{"displayName":"Matcap亮度調整"}},"_Spec":{"type":13,"value":[1],"editor":{"displayName":"Gloss光澤強度"}},"_Rim":{"type":13,"value":[0.3],"editor":{"displayName":"邊光強度"}},"_RimSoft":{"type":13,"value":[3],"editor":{"displayName":"邊光柔和度"}},"_RimCol":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Rim邊光顏色","type":"color"}},"_DissolveTex":{"value":"white","type":29,"editor":{"displayName":"Dissolve溶解圖(灰階R通道 黑色先溶解)"}},"_RampTex":{"value":"black","type":29,"editor":{"displayName":"1D漸層圖 左黑(結束) 右白(開始)"}},"_DTileOffset":{"type":16,"value":[2,2,0,0],"editor":{"displayName":"溶解圖UV縮放偏移"}},"_DThres":{"type":13,"value":[-0.1],"editor":{"displayName":"Thres溶解進度範圍"}},"_DEdge":{"type":13,"value":[5],"editor":{"displayName":"Edge溶解邊緣寬度"}},"_Sat":{"type":13,"value":[1.1],"editor":{"displayName":"Saturate飽和度調整"}},"_Cont":{"type":13,"value":[1.1],"editor":{"displayName":"Contrast對比度調整"}},"_AddColor":{"type":16,"value":[0,0,0,1],"editor":{"displayName":"擊中加色","type":"color"}},"_AddColorIntensity":{"type":13,"value":[0.5],"editor":{"displayName":"擊中色強度"}}}}]}]]],0,0,[],[],[]]